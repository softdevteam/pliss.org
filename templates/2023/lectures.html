<%include file="header.inc" args="title='Lectures'"/>
<!-- Main -->
<section id="main" class="wrapper">
  <div class="container">
    <header class="major special"><h2>Lectures</h2><p></p></header>
    <div class="content">
      <div id="hermans" style="margin-top: -6em; position: absolute"></div>
      <header>
        <h4>Gradual Programming with Hedy
          <span class="and">and</span>
          Creating Programming Languages in non-English
        </h4>
        <p>Felienne Hermans</p>
      </header>
      <p></p>
      <hr>

      <div id="sophia" style="margin-top: -6em; position: absolute"></div>
      <header>
        <h4>Verona: co-designing the type system, concurrency model, and runtime system</h4>
        <p>Sophia Drossopoulou</p>
      </header>
      <p>Verona is a language designed and implemented by teams at
	Microsoft, Uppsalla and Imperial College. Building on the
	teams’ experiences with Pony, the new language aims to support
	high-level, high-performance, highly-convenience, safe systems
	programming.  Verona extends the actor paradigm with
	asynchronous execution so that multiple actors may form
	temporal alliances and execute behaviours in concert. It has
	an ownership-based type system that ensures data race freedom
	and supports fine-grained, region-specific garbage collection.
	I will introduce Verona through examples and explore the
	design space of causal ordering for behaviours and their
	ramifications when reasoning about Verona.  I will outline the
	implementation of a C++ runtime and compare Verona to Pony. </P>
      <hr>

      <div id="marr" style="margin-top: -6em; position: absolute"></div>
      <header>
      <h4>Interpreters: Everywhere and All the Time</h4>
      <p>Stefan Marr</p>
      </header>
      <p>Implementers often start with an interpreter to sketch how a
	language may work.  They are easy to implement and great to
	experiment with.  However, they are also an essential part of
	dynamic language implementations. We will talk about the
	basics of abstract syntax trees, bytecodes, and how these
	ideas can be used to implement a language.  We will also look
	into optimizations for interpreters: how AST and bytecode
	interpreters can use run-time feedback to improve performance,
	and discuss how super nodes and super instructions allows us
	to make effective use of modern CPUs.</P>
      <header>
	<h4>A Brief Introduction to Just-in-Time Compilation</h4>
	<p>Stefan Marr</p>
      </header>
      <p>Since the early days of object-oriented languages, run-time
      polymorphism has been a challenge for implementers.  Smalltalk
      and Self pushed many ideas to an extreme, their implementers had
      to invent techniques such as: lookup caches, tracing and
      method-based compilation, deoptimization, and maps.  While these
      ideas originated in the '80s and ‘90s, they are key ingredients
      of today’s just-in-time compilers for Java, Ruby, Python,
      JavaScript.   </p>

      <hr>

      <div id="serrano" style="margin-top: -6em; position: absolute"></div>
      <header>
      <h4>JavaScript AOT compilation</h4>
      <p>Manuel Serrano</p>
      </header>
      <p>
      JavaScript is difficult to implement efficiently because
      expressions have meanings that involve all sorts of different
      executions not distinguished by any syntactic or type
      annotation. The intuition is that only JIT compilers can handle
      it efficiently because they rely on heuristic-based strategies
      that require both program and data.  Static (AOT) compilers can
      speculate and use heuristics too!  To demonstrate, we propose
      Hopc, an AOT compiler for JavaScript, based on the following
      assumption: The most likely data structure a program will use is
      the one for which the compiler can produce its best code.  Thus,
      contrary to most AOTs, Hopc does not rely on complex static
      analyses. It simply generates its best code that it protects
      with guards.  In this lecture, I will present the basic
      techniques for compiling classical dynamically typed functional
      programming such as Scheme, and then dig into the specificities
      of JavaScript.
      </p>
      <hr>

      <div id="lippautz" style="margin-top: -6em; position: absolute"></div>
      <header>
      <h4>Web rendering architecture, now and the future</h4>
      <p>Michael Lippautz</p>
      </header>
      <p>
      </p>
      <hr>

      <div id="su" style="margin-top: -6em; position: absolute"></div>
      <header>
      <h4>Solidifying the Software Foundationse</h4>
      <p>Michael Lippautz</p>
      </header>
      <p>Software applications and technologies are built on top of
	foundational systems such as compilers, databases, and theorem
	provers. Such foundations form the trusted computing base, and
	fundamentally impact software quality and security. Thus,
	solidifying them is a critical challenge. These lectures will
	introduce general, effective techniques, and extensive,
	impactful efforts on finding thousands of critical issues in
	widely-used compilers, database management systems, and SMT
	solvers. They will focus on the high-level principles and core
	techniques, their significant practical successes, and future
	opportunities and challenges.
      </p>
      <hr>

      
      <div id="wadler" style="margin-top: -6em; position: absolute"></div>
      <header>
      <h4>Programming Language Foundations in Agda</h4>
      <p>Phil Wadler</p>
      </header>
      <p> The most profound connection between logic and computation
	is a pun. The doctrine of Propositions as Types asserts that a
	certain kind of formal structure may be read in two ways:
	either as a proposition in logic or as a type in
	computing. Further, a related structure may be read as either
	the proof of the proposition or as a programme of the
	corresponding type. Further still, simplification of proofs
	corresponds to evaluation of programs.  Accordingly, the title
	of this course also has two readings. It may be parsed as
	“(Programming Language) Foundations in Agda” or “Programming
	(Language Foundations) in Agda” — the specifications we will
	write in the proof assistant Agda both describe programming
	languages and are themselves programmes.  The textbook for the
	course is a literate Agda script, freely available online at
	https://plfa.inf.ed.ac.uk. </p>
      <hr>


    </div>

    <div class="container">    
      <header class="major special"><h2>Workshop talks</h2><p></p></header>
      <div class="content">
	<div id="darius" style="margin-top: -6em; position: absolute"></div>
	<header><h4>In situ lowering for the incremental introduction of an IR</h4> <p>Darius Blasband</p> </header>

	<div id="james" style="margin-top: -6em; position: absolute"></div>
	<header><h4>RUST: Regions, Uniqueness, Ownership & Types</h4> <p>James Noble</p> </header>

	<div id="tobias" style="margin-top: -6em; position: absolute"></div>
	<header><h4>Adventures in Fully Concurrent Garbage Collection</h4> <p>Tobias Wrigstad</p> </header>

	<div id="david" style="margin-top: -6em; position: absolute"></div>
	<header><h4>Architecture of the multi-language static analysis platform Infer</h4> <p>David Piachardie</p> </header>

	<div id="jan" style="margin-top: -6em; position: absolute"></div>
	<header><h4>Reusable Just in time compilation</h4> <p>Jan Vitek</p> </header>

	<div id="suresh" style="margin-top: -6em; position: absolute"></div>
	<header><h4>Verification of Property-Based Test Generators</h4> <p>Suresk Jagannathan</p> </header>

  </div>
</section>

<%include file="footer.inc" />
